%option yylineno
%pointer

%{
    #include <cstdlib>
    #include <cerrno>
    #include <climits>
    #include <limits>
    #include "ast.hpp"
    #include "parser.hpp"
    
	void yyerror(const char *);
%}

/* WRITEME: Copy any definitions and start conditions from Project 5 here. */
%x comment

%%

  /* WRITEME: Copy your Flex rules and actions from Project 5 here. */
"+"                     { return T_PLUS; }
"-"                     { return T_MINUS; }
"\*"                    { return T_MULTIPLY; }
"/"                     { return T_DIVIDE; }
">"                     { return T_GREATER_THAN; }
">="                    { return T_GREATER_THAN_EQUALS; }
"\("                    { return T_OPEN_PAREN; }
"\)"                    { return T_CLOSE_PAREN; }
"{"                     { return T_OPEN_BRACKET; }
"}"                     { return T_CLOSE_BRACKET; }
"->"                    { return T_RETURN_TYPE; }
";"                     { return T_SEMICOLON; }
"="                     { return T_ASSIGNMENT; }
"\."                    { return T_DOT; }
","                     { return T_COMMA; }
"\n"                    {}
"/*"                    BEGIN(comment);

<comment>[^*\n]*        
<comment>"*"+[^*/\n]*   

<comment>\n         
<comment><<EOF>>        { 
                            yyerror("Comment left unclosed"); 
                        }
<comment>"*"+"/"        BEGIN(INITIAL);

"if"                    { return T_IF; }
"else"                  { return T_ELSE; }
"while"                 { return T_WHILE; }
"do"                    { return T_DO; }
"print"                 { return T_PRINT; }
"return"                { return T_RETURN; }
"integer"               { return T_INTEGER; }
"boolean"               { return T_BOOLEAN; }
"none"                  { return T_NONE; }
"true"                  { yylval.integer_ptr = new IntegerNode(1); return T_TRUE; }
"false"                 { yylval.integer_ptr = new IntegerNode(0); return T_FALSE; }
"new"                   { return T_NEW; }
"extends"               { return T_EXTENDS; }
"equals"                { return T_EQUALS; }
"and"                   { return T_AND; }
"or"                    { return T_OR; }
"not"                   { return T_NOT; }

0|[1-9][0-9]*           { yylval.integer_ptr= new IntegerNode(atoi(yytext));
                          return T_INT; }
[a-zA-Z][a-zA-Z0-9]*    { yylval.identifier_ptr  = new IdentifierNode(yytext);
                          return  T_IDENTIFIER; }

[ \t\f\v\r]+            {}

.                 { yyerror("invalid character"); }

%%

int yywrap(void) {
  return 1;
}
